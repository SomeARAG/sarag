/* ------------------------------------------------------------------ */
/* SARAG - Linear Algebra                                             */
/* by Fabrizio Caruso                                                 */



exchange(m,i,j) :=
  block([aux,size],
 
  size : length(m),
 
  aux : m[i],
  m[i] : m[j],
  m[j] : aux,
 
  return(m)
  );

exchangeCol(m,i,j) :=
   block([aux,size,k],
   size : first(third(arrayinfo(m)))+1,
   for k : 0 thru size-1 do
      (
      aux : m[k,i],
      m[k,i] : m[k,j],
      m[k,j] : aux
      ),
   return(m)
   );



matrix2list(mtx) :=
    makelist(mtx[i],i,1,length(mtx));
    

/* list of lists -> bidimensional array */
list2array(lst) :=
  block([nRows,nCols,i,j,res],
   nRows : length(lst),
   nCols : length(lst[1]),
   res : make_array( 'any,nRows,nCols ),
   for i : 1 thru nRows do 
     for j : 1 thru nCols do
       res[i-1,j-1] : lst[i][j],
   return(res)
   ); 



/* bidimensional array -> list of lists */
array2list(arr) :=
  block([nRows,nCols,i,j,newRow,res],
   nRows : first(third(arrayinfo(arr)))+1,
   nCols : second(third(arrayinfo(arr)))+1,
   res : [],

   for i : 1 thru nRows do
     (
     newRow : [],
     for j : 1 thru nCols do
       newRow : endcons(arr[i-1,j-1],newRow),

     res : endcons(newRow,res)
     ),
   return(res)
   );

/* Fix columns exchanges */
fixColumns(m,colEx) :=
  block([i],
   colEx : reverse(colEx),
   for i : 1 thru colEx do
     exchangeCols(m,colEx[i][1],colEx[i][2]),
   return(m)
   ); 


/* It performs Gaussian elimiation on a matrix */
/* by columns exchange */
gaussElim(m) :=
  block([
         nRows : length(m),
         nCols : length(m[1]),
         g : make_array('any),
         k,i,j,flag,colExList,
         zeroRows],

  zeroRows : [],

  g : make_array('any,nRows,nCols),     

  colExList : [],  

  /* Initialization */
  for i : 0 thru nRows-1 do
     for j : 0 thru nCols-1 do
        g[i,j] : m[i+1][j+1],


 
  /* Main loop */    
  for k : 0 thru nRows-2 do
    (

    /* Test for zero row */    
    flag : TRUE,
    j : k+1,
    while flag and j <= nCols do
      if not(g[k+1-1,j-1]=0) then
         flag : FALSE
      else  
         j : j+1,
    if flag then 
      
      zeroRows : endcons(k,zeroRows),
    
   
    if not(j=k+1) and not(flag) then
      (

      colExList : endcons([k+1-1,j-1],colExList),
      exchangeCol(g,k+1-1,j-1)
      ),    

    
    if not(flag) then
    for i : k+2 thru nRows do
      (


      for j : k+2 thru nCols do
        (
        
        g[i-1,j-1] : g[i-1,j-1] - g[i-1,k+1-1]*g[k+1-1,j-1]/g[k+1-1,k+1-1]
        ),
     
     
      
      g[i-1,k+1-1] : 0
      
      
      )
    ),
  
  return([array2list(g),colExList,zeroRows])
  );



/* It computes the determinant by Gauss elimination */
/* Algorithm 8.26                                   */
gaussDet(m) :=
  block([
         g : make_array('any),
         k,i,j,flag,colEx],
 
  size : length(m), 
  g : list2array(m),      
  colEx : 0,  

  /* Initialization */
  for i : 0 thru size-1 do
     for j : 0 thru size-1 do
        g[i,j] : m[i+1][j+1],
 
  /* Main loop */    
  for k : 0 thru size-2 do
    (  
    /* Test for zero row */    
    flag : TRUE,
    j : k+1,
    while flag and j <= size do
      if not(g[k+1-1,j-1]=0) then
         flag : FALSE
      else  
         j : j+1,
    if flag then 
      return(0),
    
    /* column exchange check */
    if not(j=k+1) then
      (
      /* column exchange required */
      colEx : colEx+1,
      exchangeCol(g,k+1-1,j-1)
      ), 
    /* elimination */
    for i : k+2 thru size do
      (
      for j : k+2 thru size do
        g[i-1,j-1] : g[i-1,j-1] - g[i-1,k+1-1]*g[k+1-1,j-1]/g[k+1-1,k+1-1],
      g[i-1,k+1-1] : 0
      )
    ),
  return((-1)^colEx * product(g[i,i],i,0,size-1))
  );



/* It computes the determinant by Dogdson-Jordan-Bareiss method */
/* Algorithm 8.30                                               */
bareissDet(m) :=
  block([
         g : make_array('any),
         k,i,j,flag,colEx,oldPivot], 
  size : length(m),
  g : list2array(m),     
  colEx : 0,  
  /* Initialization */
  for i : 0 thru size-1 do
     for j : 0 thru size-1 do
        g[i,j] : m[i+1][j+1],
  oldPivot : 1,
  /* Main loop */    
  for k : 0 thru size-2 do
    (
    /* Test for zero row */    
    flag : TRUE,
    j : k+1,
    while flag and j <= size do
      if not(g[k+1-1,j-1]=0) then
         flag : FALSE
      else  
         j : j+1,
    if flag then 
      return(0),
    /* column exchange check */
    if not(j=k+1) then
      (
      /* column exchange required */
      colEx : colEx+1,
      exchangeCol(g,k+1-1,j-1)
      ),
    /* elimination */
    for i : k+2 thru size do /* column loop */
      (
      for j : k+2 thru size do /* row loop */
        (
        if k= 0 then 
          oldPivot : 1
        else
          oldPivot : g[k-1,k-1],
        g[i-1,j-1] : (g[k+1-1,k+1-1]*g[i-1,j-1]-g[i-1,k+1-1]*g[k+1-1,j-1])/oldPivot
        ),
     
      g[i-1,k+1-1] : 0      
      )
    ),
  return((-1)^colEx * g[size-1,size-1])
  );


princSubMat(m,ord) := 
  block([res:make_array('any,ord,ord),i,j],
    
  for i : 0 thru ord-1 do
    for j : 0 thru ord-1 do
      res[i,j] : m[i,j],
  return(res)
  );

extractCol(m,j,size) :=
  block([res:make_array('any,size),k],
  
  for k : 0 thru size-1 do
    res[k] : m[k,j],

  return(res)
  );

extractRow(m,i,size) :=
  block([res:make_array('any,size),k],
 
  for k : 0 thru size-1 do
    res[k] : m[i,k],

  return(res)
  );


/* Linear algebra support routines */
solveSys(mat,vec,solver) :=
  block([unk,i,j,sys,nRows,nCols,newEq],
  sys : [],
  nRows : length(mat),
  nCols : length(mat[1]),
  for i : 1 thru nRows do
    (
    newEq : Sum(mat[i][j]*unk[j],j,1,nCols)-vec[i]=0,
    sys : endcons(newEq,sys)
    ),
  return(map(second,solver(sys,makeList(unk[i],i,1,nCols))))
  );


getCoeffFromNewton(ns) :=
  block([i,j,degRes : length(ns)-1,resCoeff:make_array('any)],

   resCoeff : make_array('any,degRes+1),

   resCoeff[degRes]:1,

   for i : 1 thru degRes do
     resCoeff[degRes-i] : -1/i*Sum(ns[j+1]*resCoeff[degRes+j-i],j,1,i),


   return(resCoeff)
   );
   


matrixProd(a,b) :=
  array2list(matrixProdArray(list2array(a),list2array(b)));
     
matrixProdArray(a,b) :=
  block([i,j,k,n,m,l,res:mame_array('any)],

  n : first(third(arrayinfo(a)))+1,

  m : second(third(arrayinfo(a)))+1,
 
  if not(first(third(arrayinfo(b)))+1=m) then
    return(FALSE),
  l : second(third(arrayinfo(b)))+1,

  res : make_array('any,n,l), 

  for i : 1 thru n do
    for k : 1 thru l do
    
       res[i-1,k-1] : Sum(a[i-1,j-1]*b[j-1,k-1],j,1,m), 


  return(res)
  );

m2 : make_array('any,3,2);
m2[0,0]:"a";m2[0,1]:"b";
m2[1,0]:"c";m2[1,1]:"d";
m2[2,0]:"e";m2[2,1]:"f";
t : make_array('any,2,2);
t[0,0]:1;t[0,1]:0;t[1,0]:0;t[1,1]:1;



matrixTrace(A) :=
  block([ALen,i,res],
    ALen : numOfCols(A),

    res : 0,
    for i : 1 thru ALen do
      res : res + A[i-1,i-1],
    return(res)
    );

discreteSquareRoot(n) :=
 block([i,res],
 res : 1,
 for i : 1 thru ceiling(bfloat(n/2)) do
   if i*i >= n then
     return(i)
 );


babyGiantCharPol(A,var) :=
  babyGiantCharPolAux(list2array(A),var);

babyGiantCharPolAux(A,var) :=
   block([i,j,k,r,n,dsr,
          B:make_array('any),G:make_array('any),s:make_array('any)],

   n : numOfRows(A),
   s : make_array('any,n +1 /* +1 */),

   dsr : discreteSquareRoot(n),
   if dsr*dsr = n then 
     r : dsr+1
   else
     r : dsr,
   B : make_array('any,r-1),
   for i : 1 thru r-1 do
     B[i-1] : make_array('any,n,r),
   /* baby step */
   B[1-1] : A,
   s[0] : n,
   s[1] : matrixTrace(A),
   /* baby loop */
   for i : 1 thru r-2 do
     (
     B[i+1 -1] : matrixProdArray(A,B[i -1]),
     s[i+1] : matrixTrace(B[i+1 -1])
     ),  
   G : make_array('any,r-1),
   for j : 1 thru r-1 do
     G[j-1] : make_array('any,n,r),
   /* giant step */
   G[1 -1] : matrixProdArray(A,B[r-1 -1]),
   s[r] : matrixTrace(G[1 -1]),

   for j : 1 thru r-2 do
     (
     if (j+1)*r <= n then
       (
       G[j+1 -1] : matrixProdArray(G[1-1],G[j -1]),
       s[(j+1)*r] : matrixTrace(G[j+1 -1])
       )
     ),   
   /* Newton's sums */
   for i : 1 thru r-1 do
      for j : 1 thru r-1 do
         (
         if j*r+i <= n then 
           s[j*r+i] : matrixTrace(matrixProdArray(B[i -1],G[j -1]))
         ),
  return(list2poly(array2singleList(getCoeffFromNewton(array2singleList(s))),
        var))
);


array2singleList(arr) :=
  makelist(arr[j],j,0,first(third(arrayinfo(arr))));
