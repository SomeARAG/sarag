/* ------------------------------------------------------------------ */
/* SARAG - Linear Algebra                                             */
/* by Fabrizio Caruso                                                 */



exchange(m,i,j) :=
  block([aux,size],
 
  size : length(m),
 
  aux : m[i],
  m[i] : m[j],
  m[j] : aux,
 
  return(m)
  );

exchangeCol(m,i,j) :=
   block([aux,size,k],
   size : first(third(arrayinfo(m)))+1,
   for k : 0 thru size-1 do
      (
      aux : m[k,i],
      m[k,i] : m[k,j],
      m[k,j] : aux
      ),
   return(m)
   );



/* Fix columns exchanges */
fixColumns(m,colEx) :=
  block([i],
   colEx : reverse(colEx),
   for i : 1 thru colEx do
     exchangeCols(m,colEx[i][1],colEx[i][2]),
   return(m)
   ); 


removeElements(lst,blackList) :=
  removeElementsAux(lst,blackList,[],1);

removeElementsAux(lst,blackList,res,ind) :=
   if blackList=[] then
     append(res,lst)
   else
     if first(blackList)=ind then
       removeElementsAux(rest(lst,1),rest(blackList,1),res,ind+1)
     else
       if ind<first(blackList) then
          removeElementsAux(rest(lst,1),blackList,
                            endcons(first(lst),res),ind+1)
       else
          removeElementsAux(rest(lst,1),rest(blackList),
                            endcons(first(lst),res),ind+1);



gaussTriangularize(m) :=
  lambda([lst],
         [removeElements(array2list(first(lst)),
                         third(lst)),
          second(lst)])(gaussElimArray(m));

gaussElim(m) := 
  lambda([lst],
         [array2list(first(lst)),second(lst),third(lst)])(gaussElimArray(m));

/* It performs Gaussian elimiation on a matrix */
/* by columns exchange */
gaussElimArray(m) :=
  block([
         nRows : length(m),
         nCols : length(m[1]),
         g : make_array('any),
         k,i,j,r,flag,colExList,
         zeroRows,offset],

  offset : 0, /* it compensates for zero rows */

  zeroRows : [],

  g : make_array('any,nRows,nCols),     

  colExList : [],  

  /* Initialization */
  for i : 0 thru nRows-1 do
     for j : 0 thru nCols-1 do
        g[i,j] : m[i+1][j+1],


 
  /* Main loop */    
  k : 0, /* index of the row of the pivot */
  r : 0, /* index of the column of the pivot */

  while r<= nCols-2 and k <= nRows-2 do
    (

    /* Test for zero row */    
    flag : true,
    j : r+1,
    print("-------BEGIN-------------------"),
    print("r : ", r),
    print("nCols-2 : ", nCols-2),
    print("k : ", k),
    print("nRows-1 : ", nRows-1),
    while flag and j <= nCols do
      if not(g[k+1-1,j-1]=0) then
         flag : false
      else  
         j : j+1,
    if flag then 
      (
      zeroRows : endcons(k,zeroRows),
      offset : offset + 1,
      print("offset : ", offset)
      ),
   
    if not(j=r+1) and not(flag) then
      (

      print("exchanging cols : ", r+1, " with ", j),
      colExList : endcons([r+1-1,j-1],colExList),
      exchangeCol(g,r+1-1,j-1)
      ),    

    print("pivot col : ", r+1),
    if not(flag) then
      (
      print("no zero row above"),
      for i : k+2 thru nRows do
        (

        print("Pivot at row : ", k+1, " and col : ", r+1),
        for j : r+2 thru nCols do
          (
          print("Processing row : ", i, " and col : ", j),
          g[i-1,j-1] : 
                g[i-1,j-1] - g[i-1,r+1-1]*
                             g[k+1-1,j-1]/g[k+1-1,r+1-1]
          ),
        print("-----------"),
     
        print("Zeroing row : ", i, " and col : ", r+1),
        g[i-1,r+1-1] : 0

        ),
      r : r + 1,
      print("partial : ", array2list(g))
      ),
    k : k +1,
    print("-----------------------------")
    ),
  

  return([g,colExList,zeroRows])
  );



/* It computes the determinant by Gauss elimination */
/* Algorithm 8.26                                   */
gaussDet(m) :=
  block([
         g : make_array('any),
         k,i,j,flag,colEx],
 
  size : length(m), 
  g : list2array(m),      
  colEx : 0,  

  /* Initialization */
  for i : 0 thru size-1 do
     for j : 0 thru size-1 do
        g[i,j] : m[i+1][j+1],
 
  /* Main loop */    
  for k : 0 thru size-2 do
    (  
    /* Test for zero row */    
    flag : true,
    j : k+1,
    while flag and j <= size do
      if not(g[k+1-1,j-1]=0) then
         flag : false
      else  
         j : j+1,
    if flag then 
      return(0),
    
    /* column exchange check */
    if not(j=k+1) then
      (
      /* column exchange required */
      colEx : colEx+1,
      exchangeCol(g,k+1-1,j-1)
      ), 
    /* elimination */
    for i : k+2 thru size do
      (
      for j : k+2 thru size do
        g[i-1,j-1] : g[i-1,j-1] - g[i-1,k+1-1]*g[k+1-1,j-1]/g[k+1-1,k+1-1],
      g[i-1,k+1-1] : 0
      )
    ),
  return((-1)^colEx * product(g[i,i],i,0,size-1))
  );



/* It computes the determinant by Dogdson-Jordan-Bareiss method */
/* Algorithm 8.30                                               */
bareissDet(m) :=
  block([
         g : make_array('any),
         k,i,j,flag,colEx,oldPivot], 
  size : length(m),
  g : list2array(m),     
  colEx : 0,  
  /* Initialization */
  for i : 0 thru size-1 do
     for j : 0 thru size-1 do
        g[i,j] : m[i+1][j+1],
  oldPivot : 1,
  /* Main loop */    
  for k : 0 thru size-2 do
    (
    /* Test for zero row */    
    flag : true,
    j : k+1,
    while flag and j <= size do
      if not(g[k+1-1,j-1]=0) then
         flag : false
      else  
         j : j+1,
    if flag then 
      return(0),
    /* column exchange check */
    if not(j=k+1) then
      (
      /* column exchange required */
      colEx : colEx+1,
      exchangeCol(g,k+1-1,j-1)
      ),
    /* elimination */
    for i : k+2 thru size do /* column loop */
      (
      for j : k+2 thru size do /* row loop */
        (
        if k= 0 then 
          oldPivot : 1
        else
          oldPivot : g[k-1,k-1],
        g[i-1,j-1] : (g[k+1-1,k+1-1]*g[i-1,j-1]-g[i-1,k+1-1]*g[k+1-1,j-1])/oldPivot
        ),
     
      g[i-1,k+1-1] : 0      
      )
    ),
  return((-1)^colEx * g[size-1,size-1])
  );


princSubMat(m,ord) := 
  block([res:make_array('any,ord,ord),i,j],
    
  for i : 0 thru ord-1 do
    for j : 0 thru ord-1 do
      res[i,j] : m[i,j],
  return(res)
  );

extractCol(m,j,size) :=
  block([res:make_array('any,size),k],
  
  for k : 0 thru size-1 do
    res[k] : m[k,j],

  return(res)
  );

extractRow(m,i,size) :=
  block([res:make_array('any,size),k],
 
  for k : 0 thru size-1 do
    res[k] : m[i,k],

  return(res)
  );


/* Linear algebra support routines */
solveSys(mat,vec,solver) :=
  block([unk,i,j,sys,nRows,nCols,newEq],
  sys : [],
  nRows : length(mat),
  nCols : length(mat[1]),
  for i : 1 thru nRows do
    (
    newEq : sum(mat[i][j]*unk[j],j,1,nCols)-vec[i]=0,
    sys : endcons(newEq,sys)
    ),
  return(map(second,solver(sys,makelist(unk[i],i,1,nCols))))
  );


polyFromNewton(ns,var) :=
  list2poly(getCoeffFromNewton(ns),var);

getCoeffFromNewton(ns) :=
  array2singleList(getCoeffFromNewtonArray(singleList2array(ns)));

getCoeffFromNewtonArray(ns) :=
  block([i,j,degRes : arrayLength(ns)-1,resCoeff:make_array('any)],

   resCoeff : make_array('any,degRes+1),

   resCoeff[degRes]:1,

   for i : 1 thru degRes do
     resCoeff[degRes-i] : -1/i*sum(ns[j+1-1]*resCoeff[degRes+j-i],j,1,i),


   return(resCoeff)
   );




matrixProd(a,b) :=
  array2list(matrixProdArray(list2array(a),list2array(b)));
     
matrixProdArray(a,b) :=
  block([i,j,k,n,m,l,res:mame_array('any)],

  n : first(third(arrayinfo(a)))+1,

  m : second(third(arrayinfo(a)))+1,

 if not(first(third(arrayinfo(b)))+1=m) then
    (
    print("matrixProd) incompatible matrices"),
    print("matrixProd) a : ", a),
    print("matrixProd) b : ", b),
    return(FALSE)
    )
  else
    (
  l : second(third(arrayinfo(b)))+1,

  res : make_array('any,n,l), 

  for i : 1 thru n do
    for k : 1 thru l do
    
       res[i-1,k-1] : sum(a[i-1,j-1]*b[j-1,k-1],j,1,m), 


  return(res)
    )
  );

matrixTrace(A) :=
  block([ALen,i,res],
    ALen : numOfCols(A),

    res : 0,
    for i : 1 thru ALen do
      res : res + A[i-1,i-1],
    return(res)
    );

discreteSquareRoot(n) :=
 block([i,res],
 res : 1,
 for i : 1 thru ceiling(bfloat(n/2)) do
   if i*i >= n then
     return(i)
 );


babyGiantCharPol(A,var) :=
  babyGiantCharPolVerbose(A,var,DEFAULT_VERBOSITY);



babyGiantCharPolVerbose(A,var,verbosity) :=
  babyGiantCharPolAuxVerbose(list2array(A),var,verbosity);

babyGiantCharPolAuxVerbose(A,var,verbosity) :=
  list2poly(array2singleList(getCoeffFromNewtonArray(
         getNewtonFromMatrixVerbose(A,verbosity))),
        var);  

getNewtonFromMatrix(A) :=
  getNewtonFromMatrixVerbose(A,DEFAULT_VERBOSITY);

/* Input : a bidimensional array */
/* Output : the Newton sums of the corresponding characteristic polynomial */
getNewtonFromMatrixVerbose(A,verbosity) :=
   block([i,j,k,r,n,dsr,
          B:make_array('any),G:make_array('any),ss:make_array('any)],

   n : numOfRows(A),
   ss : make_array('any,n +1 /* +1 */),
   
   dsr : discreteSquareRoot(n),
   if verbosity>=NORMAL then
     print("getNewtonFromMatrix) discrete square root: ", dsr),   

   if dsr*dsr = n then 
     r : dsr+1
   else
     r : dsr,
   B : make_array('any,r-1),
   for i : 1 thru r-1 do
     B[i-1] : make_array('any,n,r),
   /* baby step */
   B[1-1] : A,
   ss[0] : n,
   ss[1] : matrixTrace(A),
   /* baby loop */
   for i : 1 thru r-2 do
     (
     B[i+1 -1] : matrixProdArray(A,B[i -1]),
     ss[i+1] : matrixTrace(B[i+1 -1]),

     if verbosity>= NORMAL then
        print("getNewtonFromMatrix) ss[",i+1,"] : ", ss[i+1])
     ),  
   G : make_array('any,r-1),
   for j : 1 thru r-1 do
     G[j-1] : make_array('any,n,r),
   /* giant step */
   G[1 -1] : matrixProdArray(A,B[r-1 -1]),
   ss[r] : matrixTrace(G[1 -1]),

   for j : 1 thru r-2 do
     (
     if (j+1)*r <= n then
       (
       G[j+1 -1] : matrixProdArray(G[1-1],G[j -1]),
       ss[(j+1)*r] : matrixTrace(G[j+1 -1]),

       if verbosity>= NORMAL then
          print("getNewtonFromMatrix) ss[",(j+1)*r,"] : ", ss[(j+1)*r])
       )
     ),   
   /* Newton's sums */
   for i : 1 thru r-1 do
      for j : 1 thru r-1 do
         (
         if j*r+i <= n then 
           ss[j*r+i] : matrixTrace(matrixProdArray(B[i -1],G[j -1]))
         ),

return(ss)
);

companion(pol,var) :=
  array2list(companion(pol,var));

companionArray(pol,var) :=
  block(
    [m : make_array('any),n, i,j],

    n : degree(pol,var),
    m: make_array('any,n,n),

    for j : 0 thru n - 2 do
      m[0,j] : 0,
    m[0,n-1] : -coeff(pol,var,0),

 
    for i : 1 thru n-1 do
      (
      for j : 0 thru i-2 do
        m[i,j] : 0,
      m[i,i-1] : 1,
      for j : i thru n-2 do
        m[i,j] : 0,
      m[i,n-1] : -coeff(pol,var,i)
      ),
    return(m)
    );

/* This should be changed with the algorithm shown in Proposition 4.7 */
poly2Newton(pol,var) :=
  array2singleList(getNewtonFromMatrix(companionArray(pol,var)));
